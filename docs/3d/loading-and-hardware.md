# 3D 로딩과 하드웨어 이해하기

웹 3D(예: Babylon.js) 로딩·렌더링이 **어떤 하드웨어**에 의해 영향을 받는지 정리한 문서입니다.

---

## 목차

0. [스펙·3D 씬 가늠 공식과 기준표](#0-스펙3d-씬-가늠-공식과-기준표)
1. [내장 그래픽 vs 외장 그래픽](#1-내장-그래픽-vs-외장-그래픽)
2. [RAM과 VRAM](#2-ram과-vram)
3. [VRAM·GPU가 3D에서 하는 일](#3-vramgpu가-3d에서-하는-일)
4. [어느 정도 규모에 어떤 스펙이 필요한가](#4-어느-정도-규모에-어떤-스펙이-필요한가)
5. [로딩 vs 프레임 안정화: CPU와 GPU 역할](#5-로딩-vs-프레임-안정화-cpu와-gpu-역할)
6. [CPU 코어 수와 로딩 속도](#6-cpu-코어-수와-로딩-속도)

---

## 0. 스펙·3D 씬 가늠 공식과 기준표

**목표:** 그래픽카드·CPU·RAM만 보고 “어느 정도 3D 씬이 로드 가능한가”를 가늠하고, 반대로 “이 정도 3D면 어느 정도 스펙이 필요한가”를 말할 수 있게 하는 방법.

### 0.1 두 가지 질문

| 질문 | 판단 순서 |
|------|-----------|
| **이 스펙이면 어떤 3D까지 로드 가능한가?** | VRAM(GPU) → CPU → RAM 순으로 보고, 아래 기준표의 **하/중/상** 중 어디에 해당하는지 맞춤. |
| **이 3D면 어떤 스펙이 필요한가?** | 씬을 **하/중/상**으로 나눈 뒤, 기준표에서 해당 행의 GPU·VRAM·RAM·CPU를 “필요 스펙”으로 말함. |

### 0.2 씬 무게(하/중/상) 정하는 기준

- **폴리곤**: 하 ~10만 이하, 중 10만~100만, 상 100만 이상
- **텍스처**: 하 1K 소수, 중 2K 여러 장, 상 4K 다수·환경맵
- **조명·효과**: 하 조명 1~2·그림자 없음, 중 PBR+그림자+후처리, 상 다수 조명·그림자·인스턴스
- **해상도**: 하 1080p 이하, 중 1080p~1440p, 상 1440p~4K

→ 네 가지를 보고 **하(가벼운) / 중(보통) / 상(무거운)** 중 하나로 고정한 뒤 아래 표를 씀.

### 0.3 상·중·하 3D 씬 기준표 (필요 스펙)

| 구분 | 씬 특성 | GPU | VRAM | RAM | CPU | 추가로 생각할 것 |
|------|---------|-----|------|-----|-----|------------------|
| **하 (가벼운)** | 단일 모델, 조명 2~3개, 그림자 없음/낮음, 1080p 이하 | 내장 ~ GT 1030 | 1~2GB | 8GB | 4코어, 최근 세대 | 내장이면 VRAM 대신 RAM 공유 → 8GB는 여유 있게. |
| **중 (보통)** | PBR+그림자+후처리, 1080p~1440p | GTX 1650 / RX 5500급 | **4GB 이상** | **16GB** | 4코어 8스레드 | 내장만 있으면 품질 낮추거나 1080p 고정. 해상도 올리면 VRAM·GPU 부담 ↑ |
| **상 (무거운)** | 대규모 씬, 다수 조명·그림자·인스턴스, 1440p~4K | RTX 3060 / RX 6600 이상 | **6~8GB 이상** | **32GB** | 6코어 12스레드, 싱글 성능 좋은 것 | 동적 오브젝트·실시간 라이팅 많으면 CPU·GPU 둘 다 여유 있게. |

### 0.3-1 상/중/하 예시 (three.js 공식 예시 페이지)

아래 링크들은 **실제로 three.js로 구현된 페이지**라서, “하/중/상”을 체감하기 좋습니다. (기기/브라우저/해상도에 따라 체감은 달라질 수 있음)

| 구분 | 예시(three.js) | 왜 이 티어로 보기 좋은가 |
|------|----------------|--------------------------|
| **하 (가벼운)** | [webgl_geometries](https://threejs.org/examples/webgl_geometries.html) | 단순 지오메트리·재질 위주라 GPU/VRAM 부담이 낮음 |
| **중 (보통)** | [webgl_loader_gltf](https://threejs.org/examples/webgl_loader_gltf.html) | glTF 로딩 + 환경조명(HDRI)로 “실제 서비스에서 흔한 무게”를 체감 가능 |
| **상 (무거운)** | [webgl_instancing_performance](https://threejs.org/examples/webgl_instancing_performance.html) / [webgl_postprocessing_unreal_bloom](https://threejs.org/examples/webgl_postprocessing_unreal_bloom.html) / [webgl_shadowmap_performance](https://threejs.org/examples/webgl_shadowmap_performance.html) | 인스턴싱/후처리/그림자는 GPU 연산·VRAM·프레임 안정에 부담이 커서 “상” 체감에 좋음 |

> **팁(비교할 때)**  
> 같은 PC에서도 **브라우저 창 크기(해상도)**만 바꿔도 체감이 크게 달라집니다. 하/중/상 비교는 가능하면 **동일 해상도(예: 1920×1080)**로 맞추고 보는 게 좋아요.

### 0.4 한 줄 공식

- **스펙 → 씬:** “**VRAM + GPU 티어**로 먼저 하/중/상을 정하고, **CPU·RAM**이 그 티어에 맞는지 보면 **이 정도 3D는 로드 가능하다/어렵다**라고 말할 수 있다.”
- **씬 → 스펙:** “**폴리곤·텍스처·조명·해상도**로 **하/중/상**을 정한 뒤, 표에서 해당 행의 **VRAM → GPU → CPU → RAM**을 **이 3D면 이 정도가 필요하다**라고 말하면 된다.”

---

## 1. 내장 그래픽 vs 외장 그래픽

### 1.1 차이 요약

| 구분 | 내장 그래픽 (iGPU) | 외장 그래픽 (dGPU) |
|------|-------------------|---------------------|
| 위치 | CPU와 같은 칩 | 별도 그래픽 카드 |
| 메모리 | 시스템 RAM 일부 공유 | 전용 VRAM |
| 연산 성능 | 상대적으로 낮음 | 훨씬 높음 |
| 용도 | 일반 웹, 가벼운 3D | 게임, 고품질 3D |

### 1.2 비유: 주방 하나 vs 주방·창고 따로

- **내장**: CPU와 **같은 주방**을 씀. 재료(텍스처·모델)도 **그 주방 옆 냉장고(시스템 RAM)**에만 둠.
- **외장**: **그래픽 전용 주방 + 전용 냉장고(VRAM)**가 따로 있음. 재료를 한 번 그쪽으로 옮겨두면 반복해서 빠르게 요리(렌더링) 가능.

### 1.3 3D 로드할 때 체감 차이

- **내장**: GLB 받은 뒤 텍스처 올리기·셰이더 준비가 느려 **로딩 완료(안정화)** 시간이 길어지기 쉬움.
- **외장**: 같은 GLB여도 준비가 빨라 **로딩 완료(안정화)** 시간이 짧게 나오기 쉬움.
- **8프레임 안정화**: 내장은 한 프레임당 시간이 길어 8프레임만 해도 1초 넘게 걸릴 수 있고, 외장은 0.1초대에 끝나는 경우가 많음.

> **핵심요약**  
> 내장 = CPU와 메모리 나눠 쓰는 그래픽 → 3D 로드·프레임 안정화가 상대적으로 느리기 쉽다.  
> 외장 = 그래픽 전용 칩 + 전용 VRAM → 같은 3D여도 로딩 완료(안정화) 시간이 짧게 나오기 쉽다.

**가늠할 때 더 생각할 것**
- **내장만 있을 때:** “이 3D는 로드 가능한가?” → 기준표에서 **하(가벼운)** 수준에 맞추고, 중(보통) 이상이면 품질·해상도 낮춰서 가늠. “이 3D면 어떤 스펙?” → 중/상 씬이면 **외장 GPU + VRAM 4GB 이상** 필요하다고 말하면 됨.
- **원격/가상 화면**(예: Microsoft Remote Display Adapter): 실제 GPU를 못 쓰면 로딩·프레임이 크게 느려지므로, “이 스펙”으로 3D를 가늠할 때 **제외**하거나 “원격 환경에서는 10~20초대 가능”처럼 별도로 말함.

---

## 2. RAM과 VRAM

### 2.1 RAM이란

- **RAM** = 컴퓨터가 “지금 작업하는 것”을 올려두는 공간. **책상**에 비유.
- CPU가 코드·데이터를 이 책상에 펼쳐두고 일함.
- 전원이 꺼지면 비워짐(휘발성).
- 브라우저, OS, 3D 앱이 **다 같이 이 책상을 나눠 씀**.

**3D 로드할 때:** HTML/JS, GLB, Babylon 라이브러리 등이 **먼저 RAM으로** 들어옴. RAM이 부족하면 로딩이 느려지거나 끊길 수 있음.

### 2.2 VRAM이란

- **VRAM** = 그래픽 카드가 “그림 그릴 때 쓸 데이터”를 넣어두는 **전용 공간**. **그래픽 전용 책상**.
- 텍스처, 3D 메쉬, 셰이더 데이터가 여기 올라감.
- **외장 그래픽**에는 VRAM이 따로 있고, **내장 그래픽**은 VRAM이 없어 **RAM 일부를 빌려 씀**.

**3D 로드할 때:** GLB·텍스처가 RAM에 있다가, GPU가 그릴 때 **VRAM(또는 GPU가 쓰는 메모리)**으로 옮겨짐. VRAM이 크고 빠를수록 “옮기기 + 그리기”가 빨라져 로딩·첫 화면이 빨라짐.

### 2.3 한 줄 비교

| | RAM | VRAM |
|---|-----|------|
| 비유 | CPU가 쓰는 “책상” | GPU가 쓰는 “그래픽 전용 책상” |
| 3D 로드 시 | JS·GLB·리소스가 먼저 여기 올라옴 | 텍스처·메쉬가 여기 있어야 GPU가 빠르게 그림 |
| 부족하면 | 전체가 느려지거나 멈춤 | 3D가 느리거나, 품질을 낮춰야 함 |

> **핵심요약**  
> RAM = 3D 데이터가 막 도착해서 풀어놓는 책상(전체 작업용).  
> VRAM = GPU가 실제로 그림 그릴 때 쓰는 전용 책상. 3D 로드할 때 둘 다 넉넉할수록, 특히 VRAM이 전용으로 있을수록 로딩·첫 화면이 유리하다.

**가늠할 때 더 생각할 것**
- **VRAM:** “이 3D면 VRAM 얼마나?” → 텍스처 총량 + 쉐도우맵 + 프레임버퍼 합의 **1.5~2배**가 필요 용량. 하=1~2GB, 중=4GB, 상=6~8GB 이상으로 맞추면 됨.
- **RAM:** “이 3D면 RAM 얼마나?” → **에셋 크기×2~3 + OS/브라우저 여유(4~8GB)**. 하=8GB, 중=16GB, 상=32GB.
- **초기 연산(빛·env)이 적은 씬:** VRAM/GPU는 로딩 속도에 상대적으로 덜 관여 → “로딩이 느리다”면 CPU·네트워크를 먼저 봄.

---

## 3. VRAM·GPU가 3D에서 하는 일

### 3.1 역할 나누기

- **연산(계산)**: 빛, 그림자, 행렬, 인스턴스 위치 등 → **GPU 코어(셰이더)**가 담당.
- **VRAM**: 그 계산에 필요한 **데이터(모델·텍스처·버퍼)**를 보관. “계산의 재료 창고”.

### 3.2 상황별 영향

| 구분 | VRAM이 하는 일 | GPU 코어가 하는 일 |
|------|----------------|---------------------|
| **빛 연산** | 텍스처·환경맵·shadow map 보관 | 픽셀마다 조명·PBR·그림자 계산 |
| **3D 그리기** | 메쉬·텍스처·프레임버퍼 보관 | 버텍스 변환, 래스터라이즈, 픽셀 셰이더 |
| **인스턴싱** | 기본 메쉬 1개 + 인스턴스 속성 버퍼 | 인스턴스별 행렬·조명 연산 |

- **빛 계산이 무거운가?** → 주로 **GPU 연산량** + VRAM에서 데이터 읽는 **대역폭**.
- **메모리를 많이 쓰는가?** → **VRAM 용량** (텍스처·해상도·효과 수가 많을수록 증가).

> **핵심요약**  
> 빛·그림자·후처리는 **GPU 코어 연산**이 주이고, 그때 쓰는 텍스처·버퍼는 **VRAM**에 있음.  
> “계산이 무겁다” = GPU 코어 + VRAM 대역폭, “메모리를 많이 쓴다” = VRAM 용량(텍스처·메쉬·인스턴스 버퍼).

**가늠할 때 더 생각할 것**
- **동적 오브젝트·실시간 라이팅이 많은 씬:** 로딩 구간에서도 CPU(파싱·씬 구성)와 GPU(업로드·첫 몇 프레임) 부담이 둘 다 커짐 → “이 3D면 CPU도 좋고 GPU도 좋아야 로딩 타임이 짧다”고 말하면 됨.
- **해상도:** 같은 씬이라도 FHD→4K면 픽셀 수 약 4배 → VRAM(프레임버퍼)·GPU 연산이 약 4배. “이 3D를 4K로 띄우면” VRAM·GPU를 한 단계 올려서 가늠.

---

## 4. 어느 정도 규모에 어떤 스펙이 필요한가

### 4.1 3D 규모 3단계

| 구분 | 가벼운 3D | 보통 3D | 무거운 3D |
|------|-----------|---------|-----------|
| 예 | 단일 모델, 조명 2~3개, 그림자 없음/낮음 | 여러 오브젝트, PBR+그림자+후처리 | 대규모 씬, 다수 조명·그림자·인스턴스 |
| 해상도 | 1080p 이하 | 1080p~1440p | 1440p~4K |

### 4.2 권장 스펙 요약

| 구분 | 가벼운 3D | 보통 3D | 무거운 3D |
|------|-----------|---------|-----------|
| **GPU** | 내장 ~ GT 1030 수준 | GTX 1650 / RX 5500 수준 | RTX 3060 / RX 6600 이상 |
| **VRAM** | 1~2GB | **4GB 이상** | **6~8GB 이상** |
| **RAM** | 8GB | **16GB** | **32GB** |
| **CPU** | 4코어, 최근 세대 | 4코어 8스레드 | 6코어 12스레드, 싱글 성능 좋은 것 |

### 4.3 누가 뭘 담당하는지

- **로딩(첫 화면·안정화)**: CPU(파싱·디코딩), RAM(에셋 공간), GPU+VRAM(업로드·첫 프레임).
- **실시간 프레임(빛·렌더링)**: GPU(연산), VRAM(텍스처·버퍼), CPU(드로우콜·로직, 보통 보조).

> **핵심요약**  
> 단일 GLB + PBR + 조명 + 그림자 + Bloom 수준(보통 3D)이면 **GPU GTX 1650급 이상, VRAM 4GB, RAM 16GB, CPU 4코어 8스레드** 정도면 1080p 60fps 근처까지 무리 없이 잡을 수 있다. 더 무거우면 GPU·VRAM을 한 단계씩 올리면 된다.

**가늠할 때 더 생각할 것**
- **로딩이 오래 걸린다** → CPU(파싱·디코딩)·네트워크·RAM(에셋 공간) 먼저 확인. 스펙이 기준표 “중” 이상인데도 느리면 캐시·네트워크·디스크를 의심.
- **로딩은 됐는데 프레임 안정까지 오래 걸린다** → GPU·VRAM·해상도. 기준표에서 GPU/VRAM을 한 단계 올리거나 해상도를 낮춰서 가늠.

---

## 5. 로딩 vs 프레임 안정화: CPU와 GPU 역할

- **페이지(로딩)**  
  HTML/JS/CSS 내려받기, 파싱, 실행, GLB·이미지 파싱·디코딩, 원격 모듈 로드 후 JS 실행  
  → **CPU + 네트워크** 영향이 큼.

- **프레임 안정**  
  씬 렌더링, 조명·그림자·후처리, “몇 프레임이 안정적으로 그려질 때까지”(예: `waitFrames(8)`)  
  → **GPU + VRAM**이 프레임을 그리는 속도를 결정해 **프레임 안정**에 직접 관여.

**정리:** “로딩이 오래 걸린다” → CPU/네트워크를 먼저 보면 되고, “로딩은 됐는데 프레임이 안정되기까지 오래 걸린다” → GPU/VRAM을 보면 됨.

> **핵심요약**  
> **CPU** = 페이지 로딩(파싱·디코딩·JS 실행)에 많이 관여.  
> **GPU** = 프레임 안정(렌더링·8프레임 대기)에 많이 관여.

**가늠할 때 더 생각할 것**
- “이 스펙이면 로딩이 얼마나 걸리나?” → **로딩 구간**은 CPU·RAM·네트워크 영향이 크므로, GPU가 약해도 파싱·디코딩이 빨라야 짧아짐. **프레임 안정 구간**은 GPU가 약하면 길어짐.
- “이 3D를 빨리 로드시키려면?” → CPU는 **싱글코어 성능** 좋은 걸로, GPU는 기준표의 해당 티어 이상으로 맞추면 됨.

---

## 6. CPU 코어 수와 로딩 속도

**코어가 많다고 로딩이 비례해서 빨라지지는 않음.**  
로딩 시 하는 일 대부분이 **한두 코어**에서만 돌기 때문.

### 6.1 로딩 시 CPU가 하는 일

- HTML/JS 파싱 → 보통 **메인 스레드 1개**
- GLB 파싱 → 대부분 **1개 스레드**
- 이미지/텍스처 디코딩 → 일부만 워커로 나눔
- JS 실행(Babylon 초기화, import) → **메인 스레드 1개**

그래서 “코어 8개 vs 16개”보다 **한 코어가 얼마나 빠른지(싱글코어 성능)**가 로딩 속도에 더 중요함.

### 6.2 코어가 도움이 되는 경우

- 백그라운드에서 다른 일(다른 탭, 백신, 앱)이 많을 때 → 그 일이 다른 코어로 가서 로딩 담당 코어를 덜 방해함.
- 멀티 스레드로 나눠 짠 작업(일부 디코딩 등) → 2~4코어 정도까지 이득이 있을 수 있으나, 8→16코어로 늘려도 로딩은 거의 그대로인 경우가 많음.

**한 줄:** 로딩 속도에는 **싱글코어 성능**(클럭, 아키텍처)이 더 중요하고, 코어 수는 “다른 일이 많을 때 로딩이 덜 밀리는가”에 영향을 줌.

> **핵심요약**  
> 로딩 속도에는 **코어 수보다 싱글코어 성능**이 더 중요하다.  
> 코어 수는 “다른 작업이 많을 때 로딩이 덜 밀리는가” 정도에 영향을 준다.

**가늠할 때 더 생각할 것**
- “이 3D면 CPU는?” → **코어 수**보다 **같은 세대에서 싱글코어가 센 CPU**를 고르면 로딩에 유리. 기준표의 4코어/6코어는 “그 티어에서 최근 세대”를 전제로 함.
- 코어 수는 “다른 앱·탭이 많을 때 로딩이 덜 밀리는가”에서만 추가로 고려하면 됨.

---

## 참고

- 브라우저가 실제로 쓰는 GPU 확인: Chrome 주소창에 `chrome://gpu` 입력.
- 노트북은 전원 옵션(절전 vs 고성능)도 GPU·로딩 체감에 영향을 줄 수 있음.

